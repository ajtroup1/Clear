# 12.clr
Welcome to Clear

*This file is a log of all activity that occured during the interpretation of your source code.*

## Lexical Analysis / Lexing / Tokenization
Lexing (or tokenization) is the process of converting a sequence of characters into a sequence of tokens.

These tokens are the simplest level of strutured data pertaining to the source code information.

*Example Token*: `let` (Type: LET, Literal: 'let')

- Optionally, the token can track other information such as line and column information, which is used for error reporting.

	- Token: `return` (Type: RETURN, Literal:'return', Line: 6, Column: 12)

The lexer reads the source code character by character and generates tokens based on the characters it reads. The lexer is also the first step in the compilation or interpretation process. The lexer is additionally responsible for removing whitespace and comments from the source code.

**Source code:** 
```js
let y = 5;
let z = -10;

for (let x = 0; x < 10; x++) {
  y = y + 1;
}

while (y > 0) {
  z = z + 1;
  y = y - 1;
}

return z;
```

Initializing lexer...

**Lexing source code...**

### Live encounters:

1. Tokenized Token::LET 'let' at [line: 1, col: 1]
1. Tokenized Token::IDENT 'y' at [line: 1, col: 5]
1. Tokenized Token::= '=' at [line: 1, col: 7]
1. Tokenized Token::INT '5' at [line: 1, col: 9]
1. Tokenized Token::; ';' at [line: 1, col: 10]
1. Encountered newline at [line: 1, col: 11]
1. Tokenized Token::LET 'let' at [line: 2, col: 1]
1. Tokenized Token::IDENT 'z' at [line: 2, col: 5]
1. Tokenized Token::= '=' at [line: 2, col: 7]
1. Tokenized Token::- '-' at [line: 2, col: 9]
1. Tokenized Token::INT '10' at [line: 2, col: 10]
1. Tokenized Token::; ';' at [line: 2, col: 12]
1. Encountered newline at [line: 2, col: 13]
1. Encountered newline at [line: 3, col: 1]
1. Tokenized Token::FOR 'for' at [line: 4, col: 1]
1. Tokenized Token::( '(' at [line: 4, col: 5]
1. Tokenized Token::LET 'let' at [line: 4, col: 6]
1. Tokenized Token::IDENT 'x' at [line: 4, col: 10]
1. Tokenized Token::= '=' at [line: 4, col: 12]
1. Tokenized Token::INT '0' at [line: 4, col: 14]
1. Tokenized Token::; ';' at [line: 4, col: 15]
1. Tokenized Token::IDENT 'x' at [line: 4, col: 17]
1. Tokenized Token::< '<' at [line: 4, col: 19]
1. Tokenized Token::INT '10' at [line: 4, col: 21]
1. Tokenized Token::; ';' at [line: 4, col: 23]
1. Tokenized Token::IDENT 'x' at [line: 4, col: 25]
1. Tokenized Token::++ '++' at [line: 0, col: 0]
1. Tokenized Token::) ')' at [line: 4, col: 28]
1. Tokenized Token::{ '{' at [line: 4, col: 30]
1. Encountered newline at [line: 4, col: 31]
1. Tokenized Token::IDENT 'y' at [line: 5, col: 3]
1. Tokenized Token::= '=' at [line: 5, col: 5]
1. Tokenized Token::IDENT 'y' at [line: 5, col: 7]
1. Tokenized Token::+ '+' at [line: 5, col: 9]
1. Tokenized Token::INT '1' at [line: 5, col: 11]
1. Tokenized Token::; ';' at [line: 5, col: 12]
1. Encountered newline at [line: 5, col: 13]
1. Tokenized Token::} '}' at [line: 6, col: 1]
1. Encountered newline at [line: 6, col: 2]
1. Encountered newline at [line: 7, col: 1]
1. Tokenized Token::WHILE 'while' at [line: 8, col: 1]
1. Tokenized Token::( '(' at [line: 8, col: 7]
1. Tokenized Token::IDENT 'y' at [line: 8, col: 8]
1. Tokenized Token::> '>' at [line: 8, col: 10]
1. Tokenized Token::INT '0' at [line: 8, col: 12]
1. Tokenized Token::) ')' at [line: 8, col: 13]
1. Tokenized Token::{ '{' at [line: 8, col: 15]
1. Encountered newline at [line: 8, col: 16]
1. Tokenized Token::IDENT 'z' at [line: 9, col: 3]
1. Tokenized Token::= '=' at [line: 9, col: 5]
1. Tokenized Token::IDENT 'z' at [line: 9, col: 7]
1. Tokenized Token::+ '+' at [line: 9, col: 9]
1. Tokenized Token::INT '1' at [line: 9, col: 11]
1. Tokenized Token::; ';' at [line: 9, col: 12]
1. Encountered newline at [line: 9, col: 13]
1. Tokenized Token::IDENT 'y' at [line: 10, col: 3]
1. Tokenized Token::= '=' at [line: 10, col: 5]
1. Tokenized Token::IDENT 'y' at [line: 10, col: 7]
1. Tokenized Token::- '-' at [line: 10, col: 9]
1. Tokenized Token::INT '1' at [line: 10, col: 11]
1. Tokenized Token::; ';' at [line: 10, col: 12]
1. Encountered newline at [line: 10, col: 13]
1. Tokenized Token::} '}' at [line: 11, col: 1]
1. Encountered newline at [line: 11, col: 2]
1. Encountered newline at [line: 12, col: 1]
1. Tokenized Token::RETURN 'return' at [line: 13, col: 1]
1. Tokenized Token::IDENT 'z' at [line: 13, col: 8]
1. Tokenized Token::; ';' at [line: 13, col: 9]
1. Tokenized Token::EOF '' at [line: 0, col: 0]
1. Tokenized Token::EOF '' at [line: 0, col: 0]


**Here is the stream of all tokens generated by the lexer:**

```
	- Token::++ '++' at [line: 0, col: 0]
	- Token::EOF '' at [line: 0, col: 0]
	- Token::EOF '' at [line: 0, col: 0]
	- Token::LET 'let' at [line: 1, col: 1]
	- Token::IDENT 'y' at [line: 1, col: 5]
	- Token::= '=' at [line: 1, col: 7]
	- Token::INT '5' at [line: 1, col: 9]
	- Token::; ';' at [line: 1, col: 10]
	- Token::LET 'let' at [line: 2, col: 1]
	- Token::IDENT 'z' at [line: 2, col: 5]
	- Token::= '=' at [line: 2, col: 7]
	- Token::- '-' at [line: 2, col: 9]
	- Token::INT '10' at [line: 2, col: 10]
	- Token::; ';' at [line: 2, col: 12]
	- Token::FOR 'for' at [line: 4, col: 1]
	- Token::( '(' at [line: 4, col: 5]
	- Token::LET 'let' at [line: 4, col: 6]
	- Token::IDENT 'x' at [line: 4, col: 10]
	- Token::= '=' at [line: 4, col: 12]
	- Token::INT '0' at [line: 4, col: 14]
	- Token::; ';' at [line: 4, col: 15]
	- Token::IDENT 'x' at [line: 4, col: 17]
	- Token::< '<' at [line: 4, col: 19]
	- Token::INT '10' at [line: 4, col: 21]
	- Token::; ';' at [line: 4, col: 23]
	- Token::IDENT 'x' at [line: 4, col: 25]
	- Token::) ')' at [line: 4, col: 28]
	- Token::{ '{' at [line: 4, col: 30]
	- Token::IDENT 'y' at [line: 5, col: 3]
	- Token::= '=' at [line: 5, col: 5]
	- Token::IDENT 'y' at [line: 5, col: 7]
	- Token::+ '+' at [line: 5, col: 9]
	- Token::INT '1' at [line: 5, col: 11]
	- Token::; ';' at [line: 5, col: 12]
	- Token::} '}' at [line: 6, col: 1]
	- Token::WHILE 'while' at [line: 8, col: 1]
	- Token::( '(' at [line: 8, col: 7]
	- Token::IDENT 'y' at [line: 8, col: 8]
	- Token::> '>' at [line: 8, col: 10]
	- Token::INT '0' at [line: 8, col: 12]
	- Token::) ')' at [line: 8, col: 13]
	- Token::{ '{' at [line: 8, col: 15]
	- Token::IDENT 'z' at [line: 9, col: 3]
	- Token::= '=' at [line: 9, col: 5]
	- Token::IDENT 'z' at [line: 9, col: 7]
	- Token::+ '+' at [line: 9, col: 9]
	- Token::INT '1' at [line: 9, col: 11]
	- Token::; ';' at [line: 9, col: 12]
	- Token::IDENT 'y' at [line: 10, col: 3]
	- Token::= '=' at [line: 10, col: 5]
	- Token::IDENT 'y' at [line: 10, col: 7]
	- Token::- '-' at [line: 10, col: 9]
	- Token::INT '1' at [line: 10, col: 11]
	- Token::; ';' at [line: 10, col: 12]
	- Token::} '}' at [line: 11, col: 1]
	- Token::RETURN 'return' at [line: 13, col: 1]
	- Token::IDENT 'z' at [line: 13, col: 8]
	- Token::; ';' at [line: 13, col: 9]
```
## Parsing
parsing description here

### Live Encounters:

1. Starting to parse the program node...

	- This requires invoking a loop until end of file is reached, and parsing statements one-by-one until that point. As statements are parsed, they are appended to the `Program`'s `Statements` slice

2. Encountered a `LET` token, calling `parseLetStatement()`...
2. Steps in parsing let statement:

	a. Assigning token to the statement to track positioning [line: 1, col: 1]

	b. Assigning valid identifier `y` to the let statement

	c. Parsing the expression to assign to the let statement...

	d. Successfully parsed a valid expression to assign to the let statement: `5`

	e. Successfully parsed the entire let statement: `let y = 5;`
2. Parsed a statement to append to program's `Statements` slice: `let y = 5;`
2. Encountered a `LET` token, calling `parseLetStatement()`...
2. Steps in parsing let statement:

	a. Assigning token to the statement to track positioning [line: 2, col: 1]

	b. Assigning valid identifier `z` to the let statement

	c. Parsing the expression to assign to the let statement...

	d. Successfully parsed a valid expression to assign to the let statement: `(-10)`

	e. Successfully parsed the entire let statement: `let z = (-10);`
2. Parsed a statement to append to program's `Statements` slice: `let z = (-10);`
2. Steps in parsing let statement:

	a. Assigning token to the statement to track positioning [line: 4, col: 6]

	b. Assigning valid identifier `x` to the let statement

	c. Parsing the expression to assign to the let statement...

	d. Successfully parsed a valid expression to assign to the let statement: `0`

	e. Successfully parsed the entire let statement: `let x = 0;`
2. Steps in parsing block statement:

	a. Assigning token to the statement to track positioning [line: 4, col: 30]

	b. Parsing block statements is pretty simple. We only need to loop through all the statements within the block and store them until we reach the end of the block, signified `}`
2. Encountered token (`y`, type 'IDENT') that doesn't have a predefined statement parse function, so it's either an expression or an assignment statement
2. Encountered an assignment statement, verifying whether the identifier is valid...

	- Identifier `y` is valid, proceeding to parse the assignment statement
2. Steps in parsing assign statement:

	a. Assigning token to the statement to track positioning [line: 5, col: 3]

	b. Parsing the expression to assign to the identifier...

	c. Successfully parsed a valid expression to assign to the identifier: `(y + 1)`

	d. Successfully parsed the entire assign statement: `y = (y + 1);`

	- Successfully parsed a statement to append to the block's `Statements` slice: `y = (y + 1);`

	c. Successfully parsed the entire block statement: `y = (y + 1);`
2. Parsed a statement to append to program's `Statements` slice: `for (let x = 0; (x < 10); (x++)) {y = (y + 1);}`
2. Steps in parsing block statement:

	a. Assigning token to the statement to track positioning [line: 8, col: 15]

	b. Parsing block statements is pretty simple. We only need to loop through all the statements within the block and store them until we reach the end of the block, signified `}`
2. Encountered token (`z`, type 'IDENT') that doesn't have a predefined statement parse function, so it's either an expression or an assignment statement
2. Encountered an assignment statement, verifying whether the identifier is valid...

	- Identifier `z` is valid, proceeding to parse the assignment statement
2. Steps in parsing assign statement:

	a. Assigning token to the statement to track positioning [line: 9, col: 3]

	b. Parsing the expression to assign to the identifier...

	c. Successfully parsed a valid expression to assign to the identifier: `(z + 1)`

	d. Successfully parsed the entire assign statement: `z = (z + 1);`

	- Successfully parsed a statement to append to the block's `Statements` slice: `z = (z + 1);`
2. Encountered token (`y`, type 'IDENT') that doesn't have a predefined statement parse function, so it's either an expression or an assignment statement
2. Encountered an assignment statement, verifying whether the identifier is valid...

	- Identifier `y` is valid, proceeding to parse the assignment statement
2. Steps in parsing assign statement:

	a. Assigning token to the statement to track positioning [line: 10, col: 3]

	b. Parsing the expression to assign to the identifier...

	c. Successfully parsed a valid expression to assign to the identifier: `(y - 1)`

	d. Successfully parsed the entire assign statement: `y = (y - 1);`

	- Successfully parsed a statement to append to the block's `Statements` slice: `y = (y - 1);`

	c. Successfully parsed the entire block statement: `z = (z + 1);y = (y - 1);`
2. Parsed a statement to append to program's `Statements` slice: `while (y > 0) z = (z + 1);y = (y - 1);`
2. Encountered token (`z`, type 'IDENT') that doesn't have a predefined statement parse function, so it's either an expression or an assignment statement
2. Did not encounter an assign (`=`) token, so this is an expression statement
2. Steps in parsing expression statement:

	a. Assigning token to the statement to track positioning [line: 13, col: 8]

	b. Parsing expression statements is extremely simple. Just parse the expression and wrap it within a Statement implementation...

	c. Successfully parsed the expression statement: `z`

	d. Successfully parsed the entire expression statement: `z`
2. Parsed a statement to append to program's `Statements` slice: `z`


**Successfully parsed the program!**

Here is your program node in tree format:
```json
&ast.Program{
  NoStatements: false,
  Statements: []ast.Statement{
    &ast.LetStatement{
      Token: token.Token{
        Type: "LET",
        Literal: "let",
        Line: 1,
        Col: 1,
      },
      Name: &ast.Identifier{
        Token: token.Token{
          Type: "IDENT",
          Literal: "y",
          Line: 1,
          Col: 5,
        },
        Value: "y",
      },
      Value: &ast.IntegerLiteral{
        Token: token.Token{
          Type: "INT",
          Literal: "5",
          Line: 1,
          Col: 9,
        },
        Value: 5,
      },
    },
    &ast.LetStatement{
      Token: token.Token{
        Type: "LET",
        Literal: "let",
        Line: 2,
        Col: 1,
      },
      Name: &ast.Identifier{
        Token: token.Token{
          Type: "IDENT",
          Literal: "z",
          Line: 2,
          Col: 5,
        },
        Value: "z",
      },
      Value: &ast.PrefixExpression{
        Token: token.Token{
          Type: "-",
          Literal: "-",
          Line: 2,
          Col: 9,
        },
        Operator: "-",
        Right: &ast.IntegerLiteral{
          Token: token.Token{
            Type: "INT",
            Literal: "10",
            Line: 2,
            Col: 10,
          },
          Value: 10,
        },
      },
    },
    &ast.ForStatement{
      Token: token.Token{
        Type: "FOR",
        Literal: "for",
        Line: 4,
        Col: 1,
      },
      Init: &ast.LetStatement{
        Token: token.Token{
          Type: "LET",
          Literal: "let",
          Line: 4,
          Col: 6,
        },
        Name: &ast.Identifier{
          Token: token.Token{
            Type: "IDENT",
            Literal: "x",
            Line: 4,
            Col: 10,
          },
          Value: "x",
        },
        Value: &ast.IntegerLiteral{
          Token: token.Token{
            Type: "INT",
            Literal: "0",
            Line: 4,
            Col: 14,
          },
          Value: 0,
        },
      },
      Condition: &ast.InfixExpression{
        Token: token.Token{
          Type: "<",
          Literal: "<",
          Line: 4,
          Col: 19,
        },
        Left: &ast.Identifier{
          Token: token.Token{
            Type: "IDENT",
            Literal: "x",
            Line: 4,
            Col: 17,
          },
          Value: "x",
        },
        Operator: "<",
        Right: &ast.IntegerLiteral{
          Token: token.Token{
            Type: "INT",
            Literal: "10",
            Line: 4,
            Col: 21,
          },
          Value: 10,
        },
      },
      Post: &ast.PostfixExpression{
        Token: token.Token{
          Type: "IDENT",
          Literal: "x",
          Line: 4,
          Col: 25,
        },
        Operator: "++",
        Left: &ast.Identifier{
          Token: token.Token{
            Type: "IDENT",
            Literal: "x",
            Line: 4,
            Col: 25,
          },
          Value: "x",
        },
      },
      Body: &ast.BlockStatement{
        Token: token.Token{
          Type: "{",
          Literal: "{",
          Line: 4,
          Col: 30,
        },
        Statements: []ast.Statement{
          &ast.AssignStatement{
            Token: token.Token{
              Type: "=",
              Literal: "=",
              Line: 5,
              Col: 5,
            },
            Name: &ast.Identifier{
              Token: token.Token{
                Type: "IDENT",
                Literal: "y",
                Line: 5,
                Col: 3,
              },
              Value: "y",
            },
            Value: &ast.InfixExpression{
              Token: token.Token{
                Type: "+",
                Literal: "+",
                Line: 5,
                Col: 9,
              },
              Left: &ast.Identifier{
                Token: token.Token{
                  Type: "IDENT",
                  Literal: "y",
                  Line: 5,
                  Col: 7,
                },
                Value: "y",
              },
              Operator: "+",
              Right: &ast.IntegerLiteral{
                Token: token.Token{
                  Type: "INT",
                  Literal: "1",
                  Line: 5,
                  Col: 11,
                },
                Value: 1,
              },
            },
          },
        },
      },
    },
    &ast.WhileStatement{
      Token: token.Token{
        Type: "WHILE",
        Literal: "while",
        Line: 8,
        Col: 1,
      },
      Condition: &ast.InfixExpression{
        Token: token.Token{
          Type: ">",
          Literal: ">",
          Line: 8,
          Col: 10,
        },
        Left: &ast.Identifier{
          Token: token.Token{
            Type: "IDENT",
            Literal: "y",
            Line: 8,
            Col: 8,
          },
          Value: "y",
        },
        Operator: ">",
        Right: &ast.IntegerLiteral{
          Token: token.Token{
            Type: "INT",
            Literal: "0",
            Line: 8,
            Col: 12,
          },
          Value: 0,
        },
      },
      Body: &ast.BlockStatement{
        Token: token.Token{
          Type: "{",
          Literal: "{",
          Line: 8,
          Col: 15,
        },
        Statements: []ast.Statement{
          &ast.AssignStatement{
            Token: token.Token{
              Type: "=",
              Literal: "=",
              Line: 9,
              Col: 5,
            },
            Name: &ast.Identifier{
              Token: token.Token{
                Type: "IDENT",
                Literal: "z",
                Line: 9,
                Col: 3,
              },
              Value: "z",
            },
            Value: &ast.InfixExpression{
              Token: token.Token{
                Type: "+",
                Literal: "+",
                Line: 9,
                Col: 9,
              },
              Left: &ast.Identifier{
                Token: token.Token{
                  Type: "IDENT",
                  Literal: "z",
                  Line: 9,
                  Col: 7,
                },
                Value: "z",
              },
              Operator: "+",
              Right: &ast.IntegerLiteral{
                Token: token.Token{
                  Type: "INT",
                  Literal: "1",
                  Line: 9,
                  Col: 11,
                },
                Value: 1,
              },
            },
          },
          &ast.AssignStatement{
            Token: token.Token{
              Type: "=",
              Literal: "=",
              Line: 10,
              Col: 5,
            },
            Name: &ast.Identifier{
              Token: token.Token{
                Type: "IDENT",
                Literal: "y",
                Line: 10,
                Col: 3,
              },
              Value: "y",
            },
            Value: &ast.InfixExpression{
              Token: token.Token{
                Type: "-",
                Literal: "-",
                Line: 10,
                Col: 9,
              },
              Left: &ast.Identifier{
                Token: token.Token{
                  Type: "IDENT",
                  Literal: "y",
                  Line: 10,
                  Col: 7,
                },
                Value: "y",
              },
              Operator: "-",
              Right: &ast.IntegerLiteral{
                Token: token.Token{
                  Type: "INT",
                  Literal: "1",
                  Line: 10,
                  Col: 11,
                },
                Value: 1,
              },
            },
          },
        },
      },
    },
    &ast.ExpressionStatement{
      Token: token.Token{
        Type: "IDENT",
        Literal: "z",
        Line: 13,
        Col: 8,
      },
      Expression: &ast.Identifier{
        Token: token.Token{
          Type: "IDENT",
          Literal: "z",
          Line: 13,
          Col: 8,
        },
        Value: "z",
      },
    },
  },
  Modules: nil,
}
```

## Evaluation
evaluation description here

